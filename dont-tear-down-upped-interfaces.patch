 fix master bug that makes already configured interfaces (in /etc/network/interfaces)
 being torn down. This causes issue for network cards that don't have a link beat and
 might caus troubles for applications that have already bound to the interface and
 don't react on netlink events (LP: #90267)

 Author: Alexander Sack <asac@jwsdot.com>

--

--- bzr.debian.0.9.5/src/NetworkManager.c	2007-07-10 16:23:59 +0000
+++ bzr.debian.0.9.5.new/src/NetworkManager.c	2007-07-11 13:11:13 +0000
@@ -140,12 +140,29 @@
 				nm_device_is_802_11_wireless (dev) ? "wireless (802.11)" : "wired Ethernet (802.3)", nm_device_get_iface (dev));
 
 			data->dev_list = g_slist_append (data->dev_list, dev);
-			nm_device_deactivate (dev);
-
-			nm_unlock_mutex (data->dev_list_mutex, __FUNCTION__);
-
-			nm_policy_schedule_device_change_check (data);
-			nm_dbus_schedule_device_status_change_signal (data, dev, NULL, DEVICE_ADDED);
+
+			/* We don't take down wired devices that are already set up when NetworkManager gets
+			 * launched.  Plays better with the system. (Actually, we now try to do the same
+			 * for wireless interfaces as well).
+			 *
+			 * asac: revived from svn revision 382 (was removed in 388)
+			 * FIXME: IPv6 here too
+			 */
+			// if (nm_device_is_802_11_wireless (dev) || !nm_device_get_ip4_address (dev)) {
+			if (!nm_device_get_ip4_address (dev)) {
+			  nm_device_deactivate (dev);
+			  nm_unlock_mutex (data->dev_list_mutex, __FUNCTION__);
+			  nm_policy_schedule_device_change_check (data);
+			  nm_dbus_schedule_device_status_change_signal (data, dev, NULL, DEVICE_ADDED);
+			} else {
+			  nm_info("Found old device up? %d ... has active link? %d", nm_device_is_up(dev), nm_device_has_active_link(dev));
+			  NMActRequest *req = nm_act_request_new(data, dev, NULL, FALSE);
+			  nm_act_request_set_stage(req, NM_ACT_STAGE_ACTIVATED);
+			  nm_device_start_activated(req);
+			  nm_info("boosted to ACTIVATED");
+			  nm_unlock_mutex (data->dev_list_mutex, __FUNCTION__);
+			  nm_device_set_active_link (dev, TRUE);
+			}
 		}
 		else
 		{

=== modified file 'src/NetworkManagerPolicy.c'
--- bzr.debian.0.9.5/src/NetworkManagerPolicy.c	2007-07-10 16:23:59 +0000
+++ bzr.debian.0.9.5.new/src/NetworkManagerPolicy.c	2007-07-11 08:56:59 +0000
@@ -324,6 +324,8 @@
 		if (nm_device_is_802_3_ethernet (old_dev))
 			has_link = nm_device_has_active_link (old_dev);
 
+		nm_info("nm_policy_device_change_check:: old_dev has_link? %d", has_link);
+
 		/* Don't interrupt a currently activating device. */
 		if (   nm_device_is_activating (old_dev)
 		    && !nm_device_can_interrupt_activation (old_dev)
@@ -365,6 +367,7 @@
 	if (!old_dev && !new_dev)
 	{
 		; /* Do nothing, wait for something like link-state to change, or an access point to be found */
+		nm_info("nm_policy_device_change_check:: !old_dev && !new_dev!!");
 	}
 	else if (!old_dev && new_dev)
 	{
@@ -381,6 +384,7 @@
 	}
 	else if (old_dev && new_dev)
 	{
+		nm_info("nm_policy_device_change_check:: old_dev && new_dev!!");
 		NMActRequest *	old_act_req = nm_device_get_act_request (old_dev);
 		gboolean		old_user_requested = nm_act_request_get_user_requested (old_act_req);
 		gboolean		old_has_link = nm_device_has_active_link (old_dev);
@@ -447,6 +451,8 @@
 		NMActRequest *	act_req = NULL;
 		gboolean has_link = TRUE;
 
+		nm_info("nm_policy_device_change_check:: lets try to switch device!");
+
 		/* Ensure ethernet devices have a link before starting activation,
 		 * partially works around Fedora #194124.
 		 */

=== modified file 'src/nm-device.c'
--- bzr.debian.0.9.5/src/nm-device.c	2007-07-10 16:23:59 +0000
+++ bzr.debian.0.9.5.new/src/nm-device.c	2007-07-11 12:59:52 +0000
@@ -586,6 +586,8 @@
 	NMData *		app_data;
 	NMActRequest *	req;
 
+	nm_info("nm_device_set_active_link start");
+
 	g_return_if_fail (self != NULL);
 	g_return_if_fail (self->priv->app_data != NULL);
 
@@ -675,6 +677,46 @@
 	return TRUE;
 }
 
+/*
+ * nm_device_start_activated
+ *
+ * Tell the device thread that the device is started activated.
+ *
+ * Returns:	TRUE on success ... device properly activated
+ * 		FALSE on error setting device up as activated
+ *
+ */
+gboolean
+nm_device_start_activated (NMActRequest *req)
+{
+	NMData *		data = NULL;
+	NMDevice *	self = NULL;
+
+	g_return_val_if_fail (req != NULL, FALSE);
+
+	data = nm_act_request_get_data (req);
+	g_assert (data);
+
+	self = nm_act_request_get_dev (req);
+	g_assert (self);
+
+	g_return_val_if_fail (!nm_device_is_activating (self), TRUE);	/* Return if activation has already begun */
+
+	// if act_request exists, we cannot start activated obviously.
+	g_return_val_if_fail (self->priv->act_request == NULL, FALSE);
+
+	nm_act_request_ref (req);
+	self->priv->act_request = req;
+	self->priv->quit_activation = FALSE;
+
+	nm_info ("Device (%s) started as activated.", nm_device_get_iface (self));
+
+	nm_act_request_set_stage (req, NM_ACT_STAGE_ACTIVATED);
+	nm_schedule_state_change_signal_broadcast (data);
+	nm_dbus_schedule_device_status_change_signal (data, self, NULL, DEVICE_NOW_ACTIVE);
+
+	return TRUE;
+}
 
 /*
  * nm_device_activate_stage1_device_prepare

=== modified file 'src/nm-device.h'
--- bzr.debian.0.9.5/src/nm-device.h	2007-06-25 13:51:34 +0000
+++ bzr.debian.0.9.5.new/src/nm-device.h	2007-07-11 12:31:51 +0000
@@ -182,6 +182,7 @@
 
 gboolean		nm_device_is_test_device	(NMDevice *dev);
 
+gboolean		nm_device_start_activated (struct NMActRequest *req);
 gboolean		nm_device_activation_start	(struct NMActRequest *req);
 void			nm_device_activate_schedule_stage1_device_prepare		(struct NMActRequest *req);
 void			nm_device_activate_schedule_stage2_device_config		(struct NMActRequest *req);

